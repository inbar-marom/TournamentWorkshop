<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Productivity with AI Tournament Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-1: #f6f3ec;
            --bg-2: #e7efe8;
            --ink: #1f2a2e;
            --muted: #5b6b73;
            --accent: #0f766e;
            --accent-strong: #0b4f4a;
            --accent-soft: #d7f0ea;
            --warm: #f4b266;
            --card: #ffffff;
            --border: rgba(31, 42, 46, 0.12);
            --shadow: 0 18px 45px rgba(25, 31, 35, 0.12);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "IBM Plex Sans", "Segoe UI", sans-serif;
            background: radial-gradient(circle at top left, rgba(15, 118, 110, 0.12), transparent 50%),
                radial-gradient(circle at 20% 40%, rgba(244, 178, 102, 0.18), transparent 45%),
                linear-gradient(135deg, var(--bg-1), var(--bg-2));
            color: var(--ink);
            padding: 28px;
            min-height: 100vh;
        }

        .page {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            gap: 22px;
        }

        .topbar {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid var(--border);
            backdrop-filter: blur(10px);
            padding: 20px 28px;
            border-radius: 18px;
            box-shadow: var(--shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
        }

        .topbar h1 {
            font-family: "Space Grotesk", "IBM Plex Sans", sans-serif;
            font-size: 1.9em;
            color: var(--accent-strong);
            letter-spacing: 0.02em;
        }

        .topbar-meta {
            display: flex;
            align-items: center;
            gap: 18px;
            flex-wrap: wrap;
        }

        .status-pill {
            padding: 8px 14px;
            border-radius: 999px;
            background: var(--accent-soft);
            color: var(--accent-strong);
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            font-size: 0.75em;
        }

        .status-pill.completed {
            background: #dcfce7;
            color: #166534;
        }

        .status-pill.in-progress {
            background: rgba(244, 178, 102, 0.28);
            color: #9a5a1a;
        }

        .status-pill.not-started {
            background: #e2e8f0;
            color: #334155;
        }

        .connection {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95em;
            color: var(--muted);
        }

        .connection-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #d1d5db;
            box-shadow: 0 0 0 6px rgba(209, 213, 219, 0.25);
        }

        .connection-dot.connected {
            background: #16a34a;
            box-shadow: 0 0 0 6px rgba(22, 163, 74, 0.2);
        }

        .connection-dot.disconnected {
            background: #dc2626;
            box-shadow: 0 0 0 6px rgba(220, 38, 38, 0.2);
        }

        .card {
            background: var(--card);
            padding: 22px;
            border-radius: 18px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
        }

        .card h2 {
            font-family: "Space Grotesk", "IBM Plex Sans", sans-serif;
            color: var(--accent-strong);
            margin-bottom: 14px;
            font-size: 1.2em;
            border-bottom: 1px solid var(--border);
            padding-bottom: 10px;
        }

        .status-card-grid {
            display: grid;
            gap: 20px;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .progress-bar {
            width: 100%;
            height: 14px;
            background: #e2e8f0;
            border-radius: 999px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            width: 0;
            background: linear-gradient(90deg, var(--accent), var(--warm));
            transition: width 0.4s ease;
        }

        .step-track {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 12px;
            justify-content: space-between;
            width: 100%;
        }

        .step-chip {
            padding: 6px 12px;
            border-radius: 999px;
            border: 1px solid var(--border);
            font-size: 0.85em;
            background: #f7f7f4;
            color: var(--muted);
        }

        .step-chip.completed {
            background: rgba(245, 158, 11, 0.15);
            color: #b45309;
            border-color: rgba(245, 158, 11, 0.3);
        }

        .step-chip.running {
            background: rgba(15, 118, 110, 0.12);
            color: var(--accent-strong);
            border-color: rgba(15, 118, 110, 0.35);
        }

        .status-panels {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 18px;
        }

        .panel-title {
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--muted);
            margin-bottom: 10px;
        }

        .panel-body {
            display: grid;
            gap: 10px;
        }

        .leaderboard-item,
        .list-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            border-radius: 12px;
            background: #f7f7f4;
            border-left: 4px solid var(--accent);
        }

        .leaderboard-item:nth-child(1) {
            border-left-color: #f59e0b;
        }

        .leaderboard-item:nth-child(2) {
            border-left-color: #94a3b8;
        }

        .leaderboard-item:nth-child(3) {
            border-left-color: #c08457;
        }

        .leaderboard-item.champion {
            font-size: 1.3em;
            padding: 16px 18px;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.15), rgba(15, 118, 110, 0.1));
            border: 2px solid #f59e0b;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.2);
        }

        .champion-label {
            display: inline-block;
            font-size: 0.65em;
            color: var(--warm);
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            margin-left: 8px;
        }

        .event-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 18px;
            padding-bottom: 18px;
            border-bottom: 1px solid var(--border);
        }

        .event-tab {
            padding: 10px 18px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: #f7f7f4;
            color: var(--muted);
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .event-tab.status-current {
            background: rgba(22, 163, 74, 0.16);
            color: #166534;
            border-color: rgba(22, 163, 74, 0.45);
        }

        .event-tab.status-past {
            background: rgba(187, 247, 208, 0.45);
            color: #166534;
            border-color: rgba(22, 163, 74, 0.25);
        }

        .event-tab.status-upcoming {
            background: #f1f5f9;
            color: #64748b;
            border-color: #cbd5e1;
        }

        .event-tab:hover {
            background: var(--accent-soft);
            border-color: var(--accent);
            color: var(--accent-strong);
        }

        .event-tab.selected {
            border-width: 3px;
            border-color: var(--accent-strong);
            font-weight: 700;
            padding: 8px 16px;
        }

        .event-tab-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        .beeping-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #16a34a;
            box-shadow: 0 0 0 0 rgba(22, 163, 74, 0.45);
            animation: beepPulse 1.2s infinite;
        }

        @keyframes beepPulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(22, 163, 74, 0.45);
            }
            70% {
                transform: scale(1.08);
                box-shadow: 0 0 0 8px rgba(22, 163, 74, 0);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(22, 163, 74, 0);
            }
        }

        .rotation-controls {
            display: flex;
            justify-content: flex-end;
            margin: -8px 0 12px;
        }

        .rotation-controls button {
            padding: 8px 14px;
            font-size: 0.82em;
            border-radius: 10px;
        }

        .group-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 10px;
        }

        .group-tab {
            padding: 8px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: #f7f7f4;
            color: var(--muted);
            cursor: pointer;
            font-size: 0.85em;
        }

        .group-tab.selected {
            border-width: 3px;
            border-color: var(--accent-strong);
            padding: 6px 10px;
            font-weight: 700;
        }

        .group-tab.final {
            background: #fef3c7;
            color: #92400e;
        }

        .standings-table {
            width: 100%;
            border-collapse: collapse;
            background: #f7f7f4;
            border-radius: 12px;
            overflow: hidden;
        }

        .standings-table th,
        .standings-table td {
            padding: 8px 10px;
            text-align: left;
            border-bottom: 1px solid var(--border);
            font-size: 0.88em;
        }

        .winner-badge {
            display: inline-block;
            margin-left: 8px;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 0.72em;
            font-weight: 700;
            letter-spacing: 0.04em;
            text-transform: uppercase;
            background: #dcfce7;
            color: #166534;
        }

        .details-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 18px;
        }

        .status-message {
            color: var(--muted);
            font-size: 0.95em;
            padding: 8px 0;
        }

        .matches-carousel {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .matches-page {
            display: grid;
            grid-auto-rows: minmax(auto, 1fr);
            gap: 8px;
            flex: 1;
            overflow-y: auto;
            animation: slideIn 0.3s ease-in-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .match-item {
            padding: 10px 12px;
            border-radius: 12px;
            background: #f7f7f4;
            border: 1px solid var(--border);
            font-size: 0.95em;
            transition: background-color 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .match-item:hover {
            background: #efefeb;
        }

        .matches-scroll-container {
            max-height: 600px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding-right: 4px;
        }

        .matches-scroll-container::-webkit-scrollbar {
            width: 8px;
        }

        .matches-scroll-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .matches-scroll-container::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 4px;
        }

        .matches-scroll-container::-webkit-scrollbar-thumb:hover {
            background: var(--accent-strong);
        }

        .match-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 2px;
        }

        .match-stage-badge {
            display: inline-flex;
            align-items: center;
            padding: 3px 10px;
            border-radius: 999px;
            font-weight: 600;
            font-size: 0.75em;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .match-stage-badge.group {
            background: #dbeafe;
            color: #1e40af;
        }

        .match-stage-badge.final {
            background: #fef3c7;
            color: #92400e;
        }

        .match-stage-badge.tiebreaker {
            background: #fee2e2;
            color: #991b1b;
        }

        .match-result {
            font-weight: 600;
            color: var(--accent-strong);
        }

        .timestamp {
            color: #6b7280;
            font-size: 0.85em;
        }

        .matches-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
        }

        .pagination-btn {
            padding: 6px 12px;
            border: 1px solid var(--border);
            background: #f7f7f4;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85em;
            color: var(--muted);
            transition: all 0.2s ease;
        }

        .pagination-btn:hover {
            background: var(--accent-soft);
            color: var(--accent-strong);
            border-color: var(--accent);
        }

        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pagination-info {
            font-size: 0.85em;
            color: var(--muted);
            white-space: nowrap;
        }

        .carousel-timer {
            font-size: 0.75em;
            color: var(--warm);
            font-weight: 600;
        }

        .group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .log-panel {
            border-radius: 18px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            padding: 0;
        }

        .log-panel summary {
            cursor: pointer;
            list-style: none;
            padding: 18px 22px;
            font-family: "Space Grotesk", "IBM Plex Sans", sans-serif;
            font-size: 1.05em;
            font-weight: 600;
            color: var(--accent-strong);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .log-panel summary::-webkit-details-marker {
            display: none;
        }

        .log-body {
            padding: 0 22px 22px;
            display: grid;
            gap: 16px;
        }

        #messages {
            height: 260px;
            overflow-y: auto;
            border: 1px solid var(--border);
            padding: 10px;
            background: #f7f7f4;
            border-radius: 10px;
            font-family: "Courier New", monospace;
            font-size: 0.9em;
        }

        .log-entry {
            margin: 5px 0;
            padding: 5px;
        }

        .log-info {
            color: #0369a1;
        }

        .log-success {
            color: #16a34a;
        }

        .log-error {
            color: #dc2626;
        }

        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 999px;
            cursor: pointer;
            font-size: 0.95em;
        }

        button:hover {
            background: #0d5c56;
        }

        button.danger {
            background: #dc2626;
        }

        @media (max-width: 800px) {
            body {
                padding: 18px;
            }

            .topbar {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="page">
        <header class="topbar">
            <h1>Productivity with AI Tournament Dashboard</h1>
            <div class="topbar-meta">
                <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 8px;">
                    <span class="status-pill not-started" id="tournamentStatus">Not Started</span>
                    <div id="countdownContainer" style="display: none; font-size: 0.9em; color: var(--warm); font-weight: 600;">
                        <div id="countdownDisplay" style="text-align: right;">üïê Starting in...</div>
                    </div>
                    <div id="israelTimeDisplay" style="font-size: 0.85em; color: var(--muted);">
                        Israel Time: <span id="israelTimeText">--:--:--</span>
                    </div>
                </div>
                <span class="connection"><span class="connection-dot" id="statusIndicator"></span><span id="statusText">Connecting...</span></span>
            </div>
        </header>

        <section class="card">
            <h2>Tournament Status</h2>
            <div class="status-card-grid">
                <div>
                    <div class="progress-header">
                        <span id="progressLabel">Event Progress</span>
                        <span id="progressPercent">0% Complete</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="step-track" id="eventSteps"></div>
                </div>

                <div class="status-panels">
                    <div>
                        <div class="panel-title">Event Champions</div>
                        <div class="panel-body" id="eventChampions">
                            <div class="status-message">No winners yet</div>
                        </div>
                    </div>
                    <div>
                        <div class="panel-title">Overall Leaders <span id="leadersNote" style="font-size: 0.75em; color: var(--muted); font-weight: 400; margin-left: 8px;">(Not Final)</span></div>
                        <div class="panel-body">
                            <div id="overallLeaders"></div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="card">
            <h2>Events Details</h2>
            <div class="event-tabs" id="eventTabs">
                <div class="status-message">No events configured</div>
            </div>
            <div style="margin-top: 16px; display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                <div style="font-weight: 600; color: var(--muted); font-size: 0.9em;">Group:</div>
                <div class="event-tabs" id="groupSelectorTabs" style="margin: 0;">
                    <div class="status-message">No groups yet</div>
                </div>
                <button id="resumeGroupAutoBtn2" onclick="resumeGroupAutoRotation()" style="display: none; padding: 6px 12px; background: var(--accent); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85em;">Return to Auto Rotation</button>
            </div>
            <div class="details-grid">
                <div>
                    <div class="panel-title">Group Standings</div>
                    <div id="groupStandings">
                        <div class="status-message">No group data yet</div>
                    </div>
                </div>
                <div>
                    <div class="panel-title">Recent Matches (Current Group)</div>
                    <div id="recentMatchesScope" class="status-message">Showing matches for the current selected group</div>
                    <div id="recentMatches">
                        <div class="status-message">No matches yet</div>
                    </div>
                </div>
            </div>
        </section>

        <details class="log-panel" id="logPanel">
            <summary>
                <span>System Details</span>
                <span id="logToggle">Show</span>
            </summary>
            <div class="log-body">
                <div id="messages"></div>
                <div>
                    <button onclick="requestCurrentState()">Get Current State</button>
                    <button onclick="clearLog()">Clear Log</button>
                </div>
            </div>
        </details>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.14/signalr.min.js"></script>
    <script>
        const connection = new signalR.HubConnectionBuilder()
            .withUrl("/tournamentHub")
            .withAutomaticReconnect([0, 0, 1000, 3000, 5000, 10000])
            .build();

            let statePollTimer = null;

        let connectionRetries = 0;
        let lastState = null;
        let groupCycleIndex = 0;
        let groupCycleTimer = null;
        let groupRefreshTimer = null;
        let recentMatches = []; // Separate array for live match streaming
        
        // Event tabs state
        let selectedEventIndex = -1;
        let eventAutoRotationEnabled = true;
        let selectedGroupName = null;
        let groupAutoRotationEnabled = true;
        let availableGroups = [];
        let tournamentSteps = [];

        connection.on("reconnected", (connectionId) => {
            connectionRetries = 0;
            logMessage(`Reconnected to hub (ID: ${connectionId})`, 'success');
            updateConnectionStatus(true);
            requestCurrentState();
        });

        connection.on("reconnecting", () => {
            connectionRetries++;
            logMessage(`Attempting reconnection (attempt ${connectionRetries})...`, 'info');
            updateConnectionStatus(false);
        });

        connection.on("CurrentState", (state) => {
            logMessage('Received current state', 'success');
            lastState = state;
            updateFromState(state);
        });

        connection.on("MatchCompleted", (match) => {
            logMessage(`Match: ${match.Bot1Name || match.bot1Name} vs ${match.Bot2Name || match.bot2Name} - Winner: ${match.WinnerName || match.winnerName || 'Draw'}`, 'info');
            addMatchToFeed(match);
        });

        connection.on("StandingsUpdated", (standings) => {
            if (standings.GroupStandings || standings.groupStandings) {
                updateGroupStandings(standings.GroupStandings || standings.groupStandings);
            }
            // Don't request current state immediately - let the 5s refresh handle it
        });

        connection.on("EventStarted", () => requestCurrentState());
        connection.on("TournamentStarted", () => requestCurrentState());
        connection.on("TournamentProgressUpdated", () => requestCurrentState());
        connection.on("TournamentCompleted", () => requestCurrentState());
        connection.on("EventCompleted", () => requestCurrentState());
        connection.on("EventStepCompleted", () => requestCurrentState());
        connection.on("SeriesProgressUpdated", () => requestCurrentState());
        connection.on("SeriesStarted", () => requestCurrentState());
        connection.on("SeriesCompleted", () => requestCurrentState());

        connection.on("SubscriptionConfirmed", (data) => {
            logMessage(data.message, 'success');
            requestCurrentState();
        });

        connection.onclose(() => {
            updateConnectionStatus(false);
            logMessage('Connection closed', 'error');
                if (statePollTimer) {
                    clearInterval(statePollTimer);
                    statePollTimer = null;
                }
        });

        async function start() {
            try {
                await connection.start();
                updateConnectionStatus(true);
                logMessage('Connected to tournament hub', 'success');
                connectionRetries = 0;
                await connection.invoke("SubscribeToUpdates");

                    if (statePollTimer) {
                        clearInterval(statePollTimer);
                    }
                    statePollTimer = setInterval(() => {
                        if (connection.state === signalR.HubConnectionState.Connected) {
                            requestCurrentState();
                        }
                    }, 2000);
            } catch (err) {
                updateConnectionStatus(false);
                logMessage(`Connection error: ${err}`, 'error');
                const delay = Math.min(1000 * Math.pow(1.5, connectionRetries), 10000);
                connectionRetries++;
                setTimeout(start, delay);
            }
        }

        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            if (connected) {
                indicator.classList.add('connected');
                indicator.classList.remove('disconnected');
                text.textContent = 'Connected';
            } else {
                indicator.classList.remove('connected');
                indicator.classList.add('disconnected');
                text.textContent = 'Disconnected';
            }
        }

        function formatStatus(status) {
            if (typeof status === 'number') {
                const statusNames = ['NotStarted', 'InProgress', 'Paused', 'Completed'];
                return statusNames[status] || 'NotStarted';
            }
            return status || 'NotStarted';
        }

        function formatGameType(gameType) {
            if (!gameType) {
                return '';
            }
            const value = gameType.toString();
            const map = {
                RPSLS: 'RPSLS',
                ColonelBlotto: 'Colonel Blotto',
                PenaltyKicks: 'Penalty Kicks'
            };
            return map[value] || value.replace(/([a-z])([A-Z])/g, '$1 $2');
        }

        function updateEventTabs(steps) {
            const container = document.getElementById('eventTabs');
            if (!steps || steps.length === 0) {
                container.innerHTML = '<div class="status-message">No events configured</div>';
                return;
            }

            // Find currently running event
            const runningIndex = steps.findIndex(step => formatStepStatus(step.Status || step.status) === 'InProgress');

            if (eventAutoRotationEnabled) {
                selectedEventIndex = runningIndex >= 0 ? runningIndex : 0;
            }

            selectedEventIndex = Math.min(selectedEventIndex, steps.length - 1);
            selectedEventIndex = Math.max(selectedEventIndex, 0);

            container.innerHTML = steps.map((step, index) => {
                const status = formatStepStatus(step.Status || step.status);
                const isRunning = status === 'InProgress';
                const isSelected = index === selectedEventIndex;
                const gameType = step.GameType || step.gameType;
                const label = formatGameType(gameType) || `Event ${step.StepIndex || step.stepIndex || (index + 1)}`;

                const statusClass = isRunning
                    ? 'status-current'
                    : status === 'Completed'
                        ? 'status-past'
                        : 'status-upcoming';

                const classes = ['event-tab', statusClass];
                if (isSelected) classes.push('selected');

                const indicator = isRunning
                    ? '<span class="beeping-dot" title="Current Event"></span>'
                    : '<span class="event-tab-indicator"></span>';

                return `<button class="${classes.join(' ')}" onclick="selectEventTab(${index})">${indicator}${label}</button>`;
            }).join('');

            updateEventRotationButton();
        }

        function selectEventTab(index) {
            eventAutoRotationEnabled = false;
            selectedEventIndex = index;
            updateEventTabs(tournamentSteps);

            // Refresh data displays with filtered data
            if (lastState) {
                updateGroupStandings(lastState.GroupStandings || lastState.groupStandings || []);
                updateRecentMatches(recentMatches);
            }
        }

        function resumeEventAutoRotation() {
            eventAutoRotationEnabled = true;
            updateEventTabs(tournamentSteps);
            if (lastState) {
                updateGroupStandings(lastState.GroupStandings || lastState.groupStandings || []);
                updateRecentMatches(recentMatches);
            }
        }

        function updateEventRotationButton() {
            let controls = document.getElementById('eventRotationControls');
            if (!controls) {
                const eventTabs = document.getElementById('eventTabs');
                if (eventTabs) {
                    controls = document.createElement('div');
                    controls.id = 'eventRotationControls';
                    controls.className = 'rotation-controls';
                    controls.innerHTML = '<button id="resumeEventAutoBtn" onclick="resumeEventAutoRotation()" style="display:none;">Return to Auto Event</button>';
                    eventTabs.insertAdjacentElement('afterend', controls);
                }
            }

            const button = document.getElementById('resumeEventAutoBtn');
            if (button) {
                button.style.display = eventAutoRotationEnabled ? 'none' : 'inline-block';
            }
        }

        // Countdown and Israel time display
        let countdownTimer = null;
        let israelTimeTimer = null;

        function formatIsraelTime(utcDateString) {
            // Parse UTC date and convert to Israel timezone (UTC+2 or UTC+3 with DST)
            const date = new Date(utcDateString);
            const israelFormatter = new Intl.DateTimeFormat('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false,
                timeZone: 'Asia/Jerusalem'
            });
            return israelFormatter.format(date);
        }

        function updateIsraelTime() {
            const now = new Date();
            const israelFormatter = new Intl.DateTimeFormat('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false,
                timeZone: 'Asia/Jerusalem'
            });
            document.getElementById('israelTimeText').textContent = israelFormatter.format(now);
        }

        function updateCountdown(scheduledStartUtc) {
            if (!scheduledStartUtc) {
                const container = document.getElementById('countdownContainer');
                if (container) container.style.display = 'none';
                if (countdownTimer) {
                    clearInterval(countdownTimer);
                    countdownTimer = null;
                }
                return;
            }

            const container = document.getElementById('countdownContainer');
            const display = document.getElementById('countdownDisplay');
            if (!container || !display) return;

            const startDate = new Date(scheduledStartUtc);
            if (isNaN(startDate.getTime())) return;

            const now = new Date();
            if (now >= startDate) {
                // Tournament has started
                container.style.display = 'none';
                if (countdownTimer) {
                    clearInterval(countdownTimer);
                    countdownTimer = null;
                }
                return;
            }

            // Show countdown
            container.style.display = 'block';

            const updateCountdownDisplay = () => {
                const now = new Date();
                const diff = startDate - now;

                if (diff <= 0) {
                    display.textContent = 'üöÄ Tournament starting now!';
                    if (countdownTimer) {
                        clearInterval(countdownTimer);
                        countdownTimer = null;
                    }
                    return;
                }

                const hours = Math.floor(diff / (1000 * 60 * 60));
                const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((diff % (1000 * 60)) / 1000);

                let timeStr = '';
                if (hours > 0) {
                    timeStr = `${hours}h ${minutes}m ${seconds}s`;
                } else if (minutes > 0) {
                    timeStr = `${minutes}m ${seconds}s`;
                } else {
                    timeStr = `${seconds}s`;
                }

                display.textContent = `üïê Starting in: ${timeStr}`;
            };

            updateCountdownDisplay();
            if (countdownTimer) clearInterval(countdownTimer);
            countdownTimer = setInterval(updateCountdownDisplay, 1000);
        }

        function updateFromState(state) {
            const tournamentState = state.TournamentState || state.tournamentState;
            const steps = tournamentState?.Steps || tournamentState?.steps || [];
            const status = formatStatus(state.Status || state.status || tournamentState?.Status || tournamentState?.status);
            const totalSteps = tournamentState?.TotalSteps || tournamentState?.totalSteps || steps.length || 0;
            const completedSteps = steps.filter(step => formatStepStatus(step.Status || step.status) === 'Completed').length;
            const progressPercent = totalSteps > 0 ? Math.round((completedSteps / totalSteps) * 100) : 0;
            const isTournamentComplete = status === 'Completed';

            // Sync recent matches from state
            const stateMatches = state.RecentMatches || state.recentMatches || [];
            if (stateMatches.length > 0) {
                recentMatches = stateMatches;
            }

            // Update tournament steps and event tabs
            tournamentSteps = steps;
            updateEventTabs(steps);

            updateStatusPill(status);
            updateProgress(progressPercent);
            updateStepTrack(steps);
            updateEventChampions(steps);
            updateOverallLeaders(state.OverallLeaderboard || state.overallLeaderboard || [], isTournamentComplete);
            updateGroupStandings(state.GroupStandings || state.groupStandings || []);
            updateRecentMatches(recentMatches);

            // Update countdown if scheduled start time is present
            const scheduledStart = state.ScheduledStartTime || state.scheduledStartTime;
            if (scheduledStart) {
                updateCountdown(scheduledStart);
            } else {
                updateCountdown(null);
            }
        }

        function updateStatusPill(status) {
            const pill = document.getElementById('tournamentStatus');
            pill.textContent = status.replace(/([a-z])([A-Z])/g, '$1 $2');
            pill.classList.remove('completed', 'not-started', 'in-progress');
            if (status === 'Completed') {
                pill.classList.add('completed');
            } else if (status === 'InProgress') {
                pill.classList.add('in-progress');
            } else if (status === 'NotStarted') {
                pill.classList.add('not-started');
            }
        }

        function updateProgress(percent) {
            document.getElementById('progressPercent').textContent = `${percent}% Complete`;
            document.getElementById('progressFill').style.width = `${percent}%`;
        }

        function formatStepStatus(status) {
            if (typeof status === 'number') {
                const statusNames = ['NotStarted', 'InProgress', 'Completed'];
                return statusNames[status] || 'NotStarted';
            }
            return status || 'NotStarted';
        }

        function updateStepTrack(steps) {
            const container = document.getElementById('eventSteps');
            if (!steps.length) {
                container.innerHTML = '<div class="status-message">No events configured</div>';
                return;
            }

            container.innerHTML = steps.map(step => {
                const status = formatStepStatus(step.Status || step.status);
                const className = status === 'InProgress'
                    ? 'running'
                    : status === 'Completed'
                        ? 'completed'
                        : '';
                const label = formatGameType(step.GameType || step.gameType) || `Event ${step.StepIndex || step.stepIndex}`;
                return `<span class="step-chip ${className}">${label}</span>`;
            }).join('');
        }

        function updateEventChampions(steps) {
            const container = document.getElementById('eventChampions');
            if (!steps || steps.length === 0) {
                container.innerHTML = '<div class="status-message">No events configured</div>';
                return;
            }

            // Show all events with their status and winners
            container.innerHTML = steps.map(step => {
                const status = formatStepStatus(step.Status || step.status);
                const winner = step.WinnerName || step.winnerName || 'TBD';
                const label = formatGameType(step.GameType || step.gameType) || `Event ${step.StepIndex || step.stepIndex}`;
                const statusBadge = status === 'Completed' 
                    ? `<span style="color: #16a34a; font-weight: 600;">‚úì ${winner}</span>`
                    : status === 'InProgress'
                        ? `<span style="color: var(--accent); font-weight: 600;">‚ßñ Running</span>`
                        : `<span style="color: var(--muted); font-weight: 500;">‚äô Pending</span>`;
                
                return `
                    <div class="list-item">
                        <span>${label}</span>
                        ${statusBadge}
                    </div>
                `;
            }).join('');
        }

        function updateOverallLeaders(leaders, isTournamentComplete = false) {
            const container = document.getElementById('overallLeaders');
            const note = document.getElementById('leadersNote');
            
            if (!leaders || leaders.length === 0) {
                container.innerHTML = '<div class="status-message">No standings available</div>';
                return;
            }

            // Update disclaimer visibility
            if (note) {
                note.style.display = isTournamentComplete ? 'none' : 'inline';
            }

            container.innerHTML = leaders.slice(0, 5).map((team, index) => {
                const isChampion = index === 0 && isTournamentComplete;
                const championClass = isChampion ? ' champion' : '';
                const championIcon = isChampion ? 'üèÜ ' : '';
                const championLabel = isChampion ? '<span class="champion-label">Tournament Champion</span>' : '';
                
                return `
                    <div class="leaderboard-item${championClass}">
                        <span>${championIcon}${index + 1}. ${team.TeamName || team.teamName}${championLabel}</span>
                        <span>${team.TotalPoints || team.totalPoints} pts</span>
                    </div>
                `;
            }).join('');
        }

        function updateGroupStandings(groups) {
            const container = document.getElementById('groupStandings');
            
            // Don't clear existing data if new data is empty but we already have groups
            if (!groups || groups.length === 0) {
                if (availableGroups && availableGroups.length > 0) {
                    // Keep showing existing groups
                    return;
                }
                container.innerHTML = '<div class="status-message">No group data yet</div>';
                const selectorContainer = document.getElementById('groupSelectorTabs');
                if (selectorContainer) {
                    selectorContainer.innerHTML = '<div class="status-message">No groups yet</div>';
                }
                return;
            }

            // Show all groups that have rankings, or match our recent matches
            const matchGroupNames = new Set(recentMatches.map(m => m.GroupLabel || m.groupLabel).filter(Boolean));
            
            const filteredGroups = groups.filter(group => {
                const rankings = group.Rankings || group.rankings || [];
                const name = group.GroupName || group.groupName || '';
                const isFinal = isFinalGroupName(name);
                
                // Show if: final group, has teams, or has matches
                return isFinal || rankings.length > 0 || matchGroupNames.has(name);
            });

            if (filteredGroups.length === 0) {
                container.innerHTML = '<div class="status-message">No groups with completed matches yet</div>';
                const selectorContainer = document.getElementById('groupSelectorTabs');
                if (selectorContainer) {
                    selectorContainer.innerHTML = '<div class="status-message">No groups yet</div>';
                }
                return;
            }

            // Store previous selected group
            const previousSelectedGroup = selectedGroupName;
            availableGroups = filteredGroups;

            const finalGroup = filteredGroups.find(group => isFinalGroupName(group.GroupName || group.groupName || ''));
            if (finalGroup && groupAutoRotationEnabled) {
                groupAutoRotationEnabled = false;
                selectedGroupName = finalGroup.GroupName || finalGroup.groupName || selectedGroupName;
            }

            // Only reset timer if rotation mode changes
            const shouldRotate = groupAutoRotationEnabled && !finalGroup && filteredGroups.length > 1;
            if (groupCycleTimer && !shouldRotate) {
                clearInterval(groupCycleTimer);
                groupCycleTimer = null;
            }

            // Preserve selected group if it still exists, otherwise select first
            if (!selectedGroupName || !filteredGroups.some(g => (g.GroupName || g.groupName) === selectedGroupName)) {
                selectedGroupName = filteredGroups[0].GroupName || filteredGroups[0].groupName;
            }

            // Only create new timer if we don't have one and should be rotating
            if (shouldRotate && !groupCycleTimer) {
                groupCycleIndex = Math.max(0, filteredGroups.findIndex(g => (g.GroupName || g.groupName) === selectedGroupName));
                groupCycleTimer = setInterval(() => {
                    groupCycleIndex = (groupCycleIndex + 1) % filteredGroups.length;
                    selectedGroupName = filteredGroups[groupCycleIndex].GroupName || filteredGroups[groupCycleIndex].groupName;
                    renderGroupSelector(filteredGroups, selectedGroupName);
                    renderGroupView(filteredGroups, selectedGroupName);
                    updateRecentMatches(recentMatches);
                }, 10000);
            }

            renderGroupSelector(filteredGroups, selectedGroupName);
            renderGroupView(filteredGroups, selectedGroupName);
            updateGroupRotationButton(finalGroup !== undefined);

            if (!groupRefreshTimer) {
                groupRefreshTimer = setInterval(() => {
                    if (lastState) {
                        const latestGroups = lastState.GroupStandings || lastState.groupStandings || [];
                        updateGroupStandings(latestGroups);
                    }
                }, 5000);
            }
        }

        function renderGroupView(groups, activeGroupName) {
            const container = document.getElementById('groupStandings');
            
            const group = groups.find(g => (g.GroupName || g.groupName) === activeGroupName) || groups[0];
            const groupName = group.GroupName || group.groupName;
            const rankings = group.Rankings || group.rankings || [];
            const completed = isGroupComplete(rankings);
            const finalGroup = isFinalGroupName(groupName);

            const rows = rankings.map(team => {
                const isLeader = (team.Rank || team.rank) === 1;
                const winnerBadge = completed && isLeader
                    ? `<span class="winner-badge">${finalGroup ? 'Event Champion' : 'Group Winner'}</span>`
                    : '';

                return `
                <tr>
                    <td>${team.Rank || team.rank}</td>
                    <td>${team.TeamName || team.teamName}${winnerBadge}</td>
                    <td>${team.Points || team.points}</td>
                    <td>${team.Wins || team.wins || 0}-${team.Draws || team.draws || 0}-${team.Losses || team.losses || 0}</td>
                </tr>
            `;
            }).join('');

            container.innerHTML = `
                <div class="group-header">
                    <span>${groupName}</span>
                    <span class="timestamp">${groupAutoRotationEnabled && !finalGroup ? 'Auto-rotates every 10s' : 'Manual / Final focus'}</span>
                </div>
                <table class="standings-table">
                    <thead>
                        <tr><th>Rank</th><th>Team</th><th>Score</th><th>W-D-L</th></tr>
                    </thead>
                    <tbody>
                        ${rows || '<tr><td colspan="4" class="status-message">No standings yet</td></tr>'}
                    </tbody>
                </table>
            `;

            selectedGroupName = groupName;
        }

        function renderGroupSelector(groups, activeGroupName) {
            const container = document.getElementById('groupSelectorTabs');
            if (!container) return;

            if (!groups || groups.length === 0) {
                container.innerHTML = '<div class="status-message">No groups yet</div>';
                return;
            }

            const tabs = groups.map(group => {
                const name = group.GroupName || group.groupName;
                const selectedClass = name === activeGroupName ? ' selected' : '';
                const finalClass = isFinalGroupName(name) ? ' final' : '';
                return `<button class="event-tab${selectedClass}${finalClass}" onclick="selectGroupTab('${name.replace(/'/g, "\\'")}')">${name}</button>`;
            }).join('');

            container.innerHTML = tabs;
        }

        function selectGroupTab(groupName) {
            groupAutoRotationEnabled = false;
            selectedGroupName = groupName;
            renderGroupSelector(availableGroups, selectedGroupName);
            renderGroupView(availableGroups, selectedGroupName);
            updateRecentMatches(recentMatches);
            updateGroupRotationButton(false);
        }

        function resumeGroupAutoRotation() {
            groupAutoRotationEnabled = true;
            updateGroupStandings(lastState?.GroupStandings || lastState?.groupStandings || []);
            updateRecentMatches(recentMatches);
        }

        function updateGroupRotationButton(isFinalFocused) {
            const button = document.getElementById('resumeGroupAutoBtn');
            const button2 = document.getElementById('resumeGroupAutoBtn2');

            if (isFinalFocused) {
                if (button) button.style.display = 'none';
                if (button2) button2.style.display = 'none';
                return;
            }

            const displayValue = groupAutoRotationEnabled ? 'none' : 'inline-block';
            if (button) button.style.display = displayValue;
            if (button2) button2.style.display = displayValue;
        }

        function isFinalGroupName(name) {
            return (name || '').toLowerCase().includes('final group-finalstandings');
        }

        function isGroupComplete(rankings) {
            const count = rankings.length;
            if (count < 2) {
                return false;
            }

            return rankings.every(team => {
                const wins = team.Wins || team.wins || 0;
                const losses = team.Losses || team.losses || 0;
                const draws = team.Draws || team.draws || 0;
                return wins + losses + draws >= (count - 1);
            });
        }

        function updateRecentMatches(matches) {
            const container = document.getElementById('recentMatches');
            const scope = document.getElementById('recentMatchesScope');
            if (!matches || matches.length === 0) {
                container.innerHTML = '<div class="status-message">No matches yet</div>';
                if (scope) {
                    scope.textContent = 'Showing matches for current selected group';
                }
                return;
            }

            const activeGroup = selectedGroupName;
            let filteredMatches = matches;
            if (activeGroup) {
                filteredMatches = matches.filter(match => (match.GroupLabel || match.groupLabel || '') === activeGroup);
            }

            if (scope) {
                scope.textContent = activeGroup
                    ? `Showing matches for: ${activeGroup} (${filteredMatches.length} matches)`
                    : 'Showing matches for current selected group';
            }

            if (filteredMatches.length === 0) {
                container.innerHTML = '<div class="status-message">No matches yet for this selected group</div>';
                return;
            }

            // Show newest first (matches already added with unshift, so no need to reverse)
            const matchesHTML = filteredMatches.map(match => {
                const bot1 = match.Bot1Name || match.bot1Name;
                const bot2 = match.Bot2Name || match.bot2Name;
                const winner = match.WinnerName || match.winnerName || 'Draw';
                const score1 = match.Bot1Score || match.bot1Score || 0;
                const score2 = match.Bot2Score || match.bot2Score || 0;
                const when = new Date(match.CompletedAt || match.completedAt).toLocaleTimeString();
                const gameLabel = formatGameType(match.GameType || match.gameType);
                const groupLabel = match.GroupLabel || match.groupLabel || '';
                
                // Determine badge class based on stage
                let badgeClass = 'group';
                if (groupLabel.toLowerCase().includes('final')) {
                    badgeClass = 'final';
                } else if (groupLabel.toLowerCase().includes('tiebreaker')) {
                    badgeClass = 'tiebreaker';
                }
                
                return `
                    <div class="match-item">
                        <div class="match-header">
                            ${groupLabel ? `<span class="match-stage-badge ${badgeClass}">${groupLabel}</span>` : ''}
                            <span class="timestamp">${gameLabel}</span>
                        </div>
                        <div class="match-result">${bot1} vs ${bot2}</div>
                        <div>Result: ${winner} (${score1}-${score2})</div>
                        <div class="timestamp">${when}</div>
                    </div>
                `;
            }).join('');

            container.innerHTML = `
                <div class="matches-scroll-container" style="max-height: 600px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px;">
                    ${matchesHTML}
                </div>
            `;
        }

        function addMatchToFeed(match) {
            // Add to local matches array for live streaming
            recentMatches.unshift(match); // Add to beginning for most recent first
            
            // Keep only last 100 matches to avoid memory bloat
            if (recentMatches.length > 100) {
                recentMatches = recentMatches.slice(0, 100);
            }
            
            updateRecentMatches(recentMatches);
            
            // Also update lastState if it exists
            if (lastState) {
                const list = lastState.RecentMatches || lastState.recentMatches || [];
                list.unshift(match);
                if (list.length > 100) {
                    lastState.RecentMatches = list.slice(0, 100);
                    lastState.recentMatches = list.slice(0, 100);
                }
            }
        }

        function logMessage(message, type = 'info') {
            const messagesDiv = document.getElementById('messages');
            const timestamp = new Date().toLocaleTimeString();
            messagesDiv.innerHTML += `<div class="log-entry log-${type}">[${timestamp}] ${message}</div>`;
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        async function requestCurrentState() {
            try {
                await connection.invoke("GetCurrentState");
                logMessage('Requested current state', 'info');
            } catch (err) {
                logMessage(`Error requesting state: ${err}`, 'error');
            }
        }

        function clearLog() {
            document.getElementById('messages').innerHTML = '';
        }

        function setupLogPanel() {
            const panel = document.getElementById('logPanel');
            const toggle = document.getElementById('logToggle');
            const updateToggle = () => {
                toggle.textContent = panel.open ? 'Hide' : 'Show';
            };
            updateToggle();
            panel.addEventListener('toggle', updateToggle);
        }

        setupLogPanel();
        
        // Start Israel time clock update
        updateIsraelTime();
        if (israelTimeTimer) clearInterval(israelTimeTimer);
        israelTimeTimer = setInterval(updateIsraelTime, 1000);
        
        start();
    </script>
</body>
</html>
